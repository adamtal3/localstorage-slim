{"version":3,"file":"localstorage-slim.js","mappings":"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","sources":["webpack://ls/webpack/universalModuleDefinition","webpack://ls/webpack/bootstrap","webpack://ls/webpack/runtime/define property getters","webpack://ls/webpack/runtime/hasOwnProperty shorthand","webpack://ls/./src/helpers.ts","webpack://ls/./src/ls.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ls\"] = factory();\n\telse\n\t\troot[\"ls\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const NOOP = (...args: unknown[]): unknown => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: any): boolean => {\n  return item !== null && item.constructor.name === 'Object';\n};\n","/*\n * https://github.com/niketpathak/localstorage-slim\n * Copyright (c) 2021 Niket Pathak\n * MIT License\n */\n\nimport { isObject, NOOP } from './helpers';\nimport type { Encrypter, Decrypter, LocalStorageConfig } from './types';\n\n// private flags\nlet hasLS: boolean;\n\nconst supportsLS = (): boolean => {\n  if (hasLS !== undefined) return hasLS;\n  hasLS = true;\n\n  try {\n    if (!localStorage) {\n      hasLS = false;\n    }\n  } catch {\n    // some browsers throw an error if you try to access local storage (e.g. brave browser)\n    // and some like Safari do not allow access to LS in incognito mode\n    hasLS = false;\n  }\n\n  // flush once on init\n  flush();\n\n  return hasLS;\n};\n\n// Apex\nconst APX = String.fromCharCode(0);\n\n// tiny obsfuscator\nconst obfus: Encrypter | Decrypter = (str, key, encrypt = true) =>\n  encrypt\n    ? [...((JSON.stringify(str) as unknown) as string[])]\n      .map((x) => String.fromCharCode(x.charCodeAt(0) + (key as number)))\n      .join('')\n    : JSON.parse([...(str as string[])].map((x) => String.fromCharCode(x.charCodeAt(0) - (key as number))).join(''));\n\nconst decrypter: Decrypter = (str, key) => {\n  return obfus(str, key, false);\n};\n\nconst config: LocalStorageConfig = {\n  ttl: null,\n  encrypt: false,\n  encrypter: obfus,\n  decrypter,\n  secret: 75,\n  prefix: null,\n};\n\nconst set = <T = unknown>(key: string, value: T, localConfig: LocalStorageConfig = {}): void | boolean => {\n  if (!supportsLS()) return false;\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n    prefix: localConfig.prefix === null ? null : localConfig.prefix || config.prefix,\n  };\n\n  try {\n    const hasTTL = _conf.ttl && !isNaN(_conf.ttl) && _conf.ttl > 0;\n    let val = hasTTL ? { [APX]: value, ttl: Date.now() + (_conf.ttl as number) * 1e3 } : value;\n\n    if (_conf.encrypt) {\n      // if ttl exists, only encrypt the value\n      if (hasTTL) {\n        (val as Record<string, unknown>)[APX] = (_conf.encrypter || NOOP)(\n          (val as Record<string, unknown>)[APX],\n          _conf.secret\n        ) as string;\n      } else {\n        val = (_conf.encrypter || NOOP)(val, _conf.secret) as T;\n      }\n    }\n\n    if (_conf.prefix) {\n      // Enclose key in prefix\n      key = `${_conf.prefix}${key}`;\n    }\n\n    localStorage.setItem(key, JSON.stringify(val));\n  } catch {\n    // Sometimes stringify fails due to circular refs\n    return false;\n  }\n};\n\nconst get = <T = unknown>(key: string, localConfig: LocalStorageConfig = {}): T | null => {\n  if (!supportsLS()) return null;\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n    prefix: localConfig.prefix === null ? null : localConfig.prefix || config.prefix,\n  };\n\n  if (_conf.prefix) {\n    // Enclose key in prefix\n    key = `${_conf.prefix}${key}`;\n  }\n\n  const str = localStorage.getItem(key);\n\n  if (!str) {\n    return null;\n  }\n\n  let item = JSON.parse(str);\n  const hasTTL = isObject(item) && APX in item;\n\n  if (_conf.decrypt || _conf.encrypt) {\n    try {\n      if (hasTTL) {\n        item[APX] = (_conf.decrypter || NOOP)(item[APX], _conf.secret) as string;\n      } else {\n        item = (_conf.decrypter || NOOP)(item, _conf.secret) as string;\n      }\n    } catch {\n      // Either the secret is incorrect or there was a parsing error\n      // do nothing [i.e. return the encrypted/unparsed value]\n    }\n  }\n\n  // if not using ttl, return immediately\n  if (!hasTTL) {\n    return item;\n  }\n\n  if (Date.now() > item.ttl) {\n    localStorage.removeItem(key);\n    return null;\n  }\n\n  return item[APX];\n};\n\nconst flush = (force = false, localConfig: LocalStorageConfig = {}): false | void => {\n  if (!supportsLS()) return false;\n  \n  const prefix = localConfig.prefix === null ? null : localConfig.prefix || config.prefix;\n  Object.keys(localStorage).forEach((key) => {\n    if (prefix && !key.startsWith(prefix)) return; // continue iteration\n    const str = localStorage.getItem(key);\n    if (!str) return; // continue iteration\n    let item;\n    try {\n      item = JSON.parse(str);\n    } catch {\n      // Some packages write strings to localStorage that are not converted by JSON.stringify(), so we need to ignore it\n      return;\n    }\n    // flush only if ttl was set and is/is not expired\n    if ((isObject(item) && APX in item) && (Date.now() > item.ttl || force)) {\n      localStorage.removeItem(key);\n    }\n  });\n};\n\nconst remove = (key: string, localConfig: LocalStorageConfig = {}): undefined | false => {\n  if (!supportsLS()) return false;\n  const prefix = localConfig.prefix === null ? null : localConfig.prefix || config.prefix;\n  if (prefix) {\n    // Enclose key in prefix\n    key = `${prefix}${key}`;\n  }\n  localStorage.removeItem(key);\n};\n\nconst clear = (localConfig: LocalStorageConfig = {}): undefined | false => {\n  if (!supportsLS()) return false;\n\n  const prefix = localConfig.prefix === null ? null : localConfig.prefix || config.prefix;\n  if (prefix) {\n    Object.keys(localStorage).forEach((key) => {\n      if (key.startsWith(`${prefix}`)) {\n        localStorage.removeItem(key);\n      }\n    });\n  }\n  else {\n    localStorage.clear();\n  }\n};\n\nexport default {\n  config,\n  set,\n  get,\n  flush,\n  clear,\n  remove,\n};\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","NOOP","args","isObject","item","constructor","name","hasLS","supportsLS","undefined","localStorage","flush","APX","String","fromCharCode","obfus","str","encrypt","JSON","stringify","map","x","charCodeAt","join","parse","config","ttl","encrypter","decrypter","secret","prefix","force","localConfig","keys","forEach","startsWith","getItem","Date","now","removeItem","set","value","_conf","hasTTL","isNaN","val","setItem","decrypt","clear","remove"],"sourceRoot":""}